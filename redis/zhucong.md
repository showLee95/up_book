Redis主从
====
### 简单概述
> 复制功能不会阻塞主服务器和从服务器，  
> 从服务器删除旧数据载入新数据，会阻塞，但也不是一直阻塞  
> 可以通过复制功能让主服务器不去执行持久化操作，降低主服务器磁盘io压力，由从服务器执行持久化操作  
> （危险，需注意）
	> 1. 假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据  
	> 2. 节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据  
	> 3. 节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。  
# !!!不要重启主服务器服务，崩溃就不要起了


# 同步过程 
> 1.从连接主机 发送psync 主库执行bgsave，并将所有新写入的命令都写入缓冲区里面  
> 2.主库执行bgsave后，把执行保存所得的.rdb文件发送给从库，从库完成全同步  
> 3.然后主库再把新写入的命令以redis的方式发送给从库，完成半同步。  
#####   即使有多个从服务器同时向主服务器发送 SYNC ， 主服务器也只需执行一次 BGSAVE 命令， 就可以处理所有这些从服务器的同步请求。
> 主库来判断从库的数据是否有效 ，如果无效就执行全同步，有效执行半同步，传送积压空间。
#####  BGSAVE保存数据到磁盘的方式：
> BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。

###   Redis主从注意
> 如果主服务器命令缓冲区数据量过大，从库速度跟不上主库 会导致主从数据不一致，陷入死循环  
> 解决方式：数据量小再执行同步，例如半夜


#  主从配置
* 配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：

	slaveof 192.168.1.1 6379
> 当然， 你需要将代码中的 192.168.1.1 和 6379 替换成你的主服务器的 IP 和端口号。

* 另外一种方法是调用 SLAVEOF host port 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：

	127.0.0.1:6379> SLAVEOF 192.168.1.1 10086  
	OK

> 1.redis key的大小不建议超过2M,性能会变慢。  
> 2.从服务器默认只读的，避免了操作失误而将数据不小心写入到了从服务器的情况。

* slaveof NO ONE 从库提升为主库
	SLAVEOF 192.168.1.1 10086 设置 192.168.1.1 为主库

